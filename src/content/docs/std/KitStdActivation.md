---
title: KitStdActivation
description: Implements activation for kit objects.
---

<!-- This file was @generated by `just docgen-kit-std`. -->

Implements activation for kit objects.

## Properties

### Activatable

```luau

KitStdActivation.Activatable: Attribute<boolean>

```

Whether if a kit object can be activated.

### ActivationBehavior

```luau

KitStdActivation.ActivationBehavior: Attribute<ActivationBehavior>

```

How to handle activation behavior.

### ActivationHumanoidStateType

```luau

KitStdActivation.ActivationHumanoidStateType: Attribute<Enum.HumanoidStateType?>

```

TBA

### ActivationInterval

```luau

KitStdActivation.ActivationInterval: Attribute<number?>

```

TBA

### ActivationKeyCode

```luau

KitStdActivation.ActivationKeyCode: Attribute<Enum.KeyCode?>

```

TBA

### Enabled

```luau

KitStdActivation.Enabled: Attribute<boolean>

```

TBA

### MaxActivationDistance

```luau

KitStdActivation.MaxActivationDistance: Attribute<number?>

```

TBA



## Functions

### onActivated

```luau
function KitStdActivation.onActivated(
	instanceTrove: trove.Trove,
	instance: T & Instance,
	onActivated: (trove: trove.Trove, instance: T) -> ()
): ()
```

Calls the callback when the connected instance is activated based on it's
`ActivationMode` attribute:
* If `ActivationMode == "Touch" and connectTo:IsA("BasePart")`, activates
  when the supported instances touch the connected instance
* If `ActivationMode == "Prompt" and connectTo:IsA("BasePart")`,
  activates when a `connectTo.ActivationProximityPrompt` ProximityPrompt -
  or creates one - is triggered. `MaxActivationDistance` is also set.
* If `ActivationMode == "Click" and connectTo:IsA("BasePart")`,
  activates when a `connectTo.ActivationClickDetector` ClickDetector - or
  creates one- is triggered. `MaxActivationDistance` is also set.
* If `ActivationMode == "KeyCode"`, it activates when `ActivationKeyCode`
  is triggered.
`onActivated` receives the connected instance so callbacks can be cached.
`onActivated` is only called if the `Active` attribute is enabled.
Once activated, the consumer should cleanup the given trove and reconnect
once it is deactivated.
This implements the following attributes for the connected instance:
* `ActivationMode`
* `MaxActivationDistance`
* `ActivationKeyCode` if `ActivationMode == "Control"`
* `SupportsCharacter` if `ActivationMode == "Control"`
* `SupportsBoxes` if `ActivationMode == "Control"`
* `BoxesRequiresMatchingId` if `ActivationMode == "Control"`
* `RequiredBoxId` if `ActivationMode == "Control"`
```luau
Self:onLoaded(function(trove, self)
    local activationTrove = trove:extend()
    local isActivated = false
    local function onSelfActivated()
        if not isActivated then
            isActivated = true
            activationTrove:clean()
            print("Activated!")
            task.delay(3, function()
                isActivated = false
                activationTrove = trove:extend()
                prelude.connectActivation(activationTrove, connectTo, onSelfActivated)
                print("Deactivated!")
            end)
        end
    end
    prelude.connectActivation(activationTrove, connectTo, onSelfActivated)
end)
```

#### Parameters

##### instanceTrove <small>`: trove.Trove`</small>



##### instance <small>`: T & Instance`</small>



##### onActivated <small>`: (trove: trove.Trove, instance: T) -> ()`</small>

